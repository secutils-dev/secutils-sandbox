/*
 * Copyright (c) 2020 Â· Marton Lederer
 * This file is a modified/simplified version of the file that was created / generated by
 * Marton Lederer in https://github.com/martonlederer/dpng. See the LICENSE on the github
 * repo https://github.com/martonlederer and https://marton.lederer.hu
 */

(() => {
  const crc32: number[] = [];
  for (let i = 0; i < 256; i++) {
    let c = i;

    for (let j = 0; j < 8; j++) {
      if (c & 1) {
        c = -306674912 ^ ((c >> 1) & 0x7fffffff);
      } else {
        c = (c >> 1) & 0x7fffffff;
      }
    }

    crc32[i] = c;
  }

  function lookUpCrc32(buffer: Uint8Array, offset: number, size: number): void {
    let crc = -1;

    for (let i = 4; i < size - 4; i++) {
      crc = crc32[(crc ^ buffer[offset + i]) & 0xff] ^ ((crc >> 8) & 0x00ffffff);
    }

    write4(buffer, offset + size - 4, crc ^ -1);
  }

  function write4(buffer: Uint8Array, offset: number, value: number): number {
    buffer[offset++] = (value >> 24) & 255;
    buffer[offset++] = (value >> 16) & 255;
    buffer[offset++] = (value >> 8) & 255;
    buffer[offset++] = value & 255;

    return offset;
  }

  function write2(buffer: Uint8Array, offset: number, value: number): number {
    buffer[offset++] = (value >> 8) & 255;
    buffer[offset++] = value & 255;

    return offset;
  }

  function write2lsb(buffer: Uint8Array, offset: number, value: number): number {
    buffer[offset++] = value & 255;
    buffer[offset++] = (value >> 8) & 255;

    return offset;
  }

  function writeString(buffer: Uint8Array, offset: number, string: string): number {
    for (let i = 0, n = string.length; i < n; i++) {
      buffer[offset++] = string.charCodeAt(i);
    }

    return offset;
  }

  /**
   * Helper interface to create valid RGB colors.
   */
  interface RGB {
    r: number;
    g: number;
    b: number;
    a: number;
  }

  const PNG_HEADER = '\x89PNG\r\n\x1A\n';

  /**
   * Creates a PNG image instance.
   */
  class PngImage {
    private readonly width: number;
    private height: number;
    private readonly depth: number;

    private readonly bit_depth: number;
    private readonly pix_format: number;
    private readonly pix_size: number;

    private readonly data_size: number;

    private readonly ihdr_offs: number;
    private readonly ihdr_size: number;
    private readonly plte_offs: number;
    private readonly plte_size: number;
    private readonly trns_offs: number;
    private readonly trns_size: number;
    private readonly idat_offs: number;
    private readonly idat_size: number;
    private readonly iend_offs: number;
    private readonly iend_size: number;
    private readonly buffer_size: number;

    private readonly buffer: Uint8Array;
    private readonly palette: Record<string, number>;
    private pIndex: number;
    private backgroundColor: number;

    constructor(width: number, height: number, depth: number = 10, backgroundColor: RGB = { r: 0, g: 0, b: 0, a: 0 }) {
      this.width = width;
      this.height = height;
      this.depth = depth;

      this.bit_depth = 8;
      this.pix_format = 3;
      this.pix_size = height * (width + 1);

      this.data_size = 2 + this.pix_size + 5 * Math.floor((0xfffe + this.pix_size) / 0xffff) + 4;

      this.ihdr_offs = 0;
      this.ihdr_size = 4 + 4 + 13 + 4;
      this.plte_offs = this.ihdr_offs + this.ihdr_size;
      this.plte_size = 4 + 4 + 3 * depth + 4;
      this.trns_offs = this.plte_offs + this.plte_size;
      this.trns_size = 4 + 4 + depth + 4;
      this.idat_offs = this.trns_offs + this.trns_size;
      this.idat_size = 4 + 4 + this.data_size + 4;
      this.iend_offs = this.idat_offs + this.idat_size;
      this.iend_size = 4 + 4 + 4;
      this.buffer_size = this.iend_offs + this.iend_size;

      const rawBuffer = new ArrayBuffer(PNG_HEADER.length + this.buffer_size);

      writeString(new Uint8Array(rawBuffer), 0, PNG_HEADER);

      const buffer = new Uint8Array(rawBuffer, PNG_HEADER.length, this.buffer_size);

      this.palette = {};
      this.buffer = buffer;
      this.pIndex = 0;

      let off = write4(buffer, this.ihdr_offs, this.ihdr_size - 12);
      off = writeString(buffer, off, 'IHDR');
      off = write4(buffer, off, width);
      off = write4(buffer, off, height);
      buffer[off++] = this.bit_depth;
      buffer[off++] = this.pix_format;
      off = write4(buffer, this.plte_offs, this.plte_size - 12);
      writeString(buffer, off, 'PLTE');
      off = write4(buffer, this.trns_offs, this.trns_size - 12);
      writeString(buffer, off, 'tRNS');
      off = write4(buffer, this.idat_offs, this.idat_size - 12);
      writeString(buffer, off, 'IDAT');
      off = write4(buffer, this.iend_offs, this.iend_size - 12);
      writeString(buffer, off, 'IEND');

      let header = ((8 + (7 << 4)) << 8) | (3 << 6);
      header += 31 - (header % 31);

      write2(buffer, this.idat_offs + 8, header);

      for (let i = 0; (i << 16) - 1 < this.pix_size; i++) {
        let size, bits;

        if (i + 0xffff < this.pix_size) {
          size = 0xffff;
          bits = 0;
        } else {
          size = this.pix_size - (i << 16) - i;
          bits = 1;
        }

        let off = this.idat_offs + 8 + 2 + (i << 16) + (i << 2);
        buffer[off++] = bits;
        off = write2lsb(buffer, off, size);
        write2lsb(buffer, off, ~size);
      }

      this.backgroundColor = this.createRGBColor(backgroundColor);
    }

    /**
     * Sets a pixel.
     */
    setPixel(x: number, y: number, color: number): void {
      const i = y * (this.width + 1) + x + 1;
      this.buffer[this.idat_offs + 8 + 2 + 5 * Math.floor(i / 0xffff + 1) + i] = color;
    }

    /**
     * Draws a line.
     */
    drawLine(x: number, y: number, width: number, height: number, color: number): void {
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          this.setPixel(x + i, y + j, color);
        }
      }
    }

    /**
     * Draws a rectangle.
     */
    drawRect(x1: number, y1: number, x2: number, y2: number, color: number): void {
      if (x1 > x2 || y1 > y2) {
        throw new Error("x2 or y2 can't be greater than x1 or y1");
      }

      this.drawLine(x1, y1, x2 - x1, y2 - y1, color);
    }

    /**
     * Returns an image buffer.
     */
    getBuffer(): Uint8Array {
      // Deflate before converting.
      const { width, height, buffer } = this,
        BASE = 65521,
        NMAX = 5552;

      let s1 = 1,
        s2 = 0,
        n = NMAX;

      const baseOffset = this.idat_offs + 8 + 2 + 5;

      for (let y = 0; y < height; y++) {
        for (let x = -1; x < width; x++) {
          const i = y * (width + 1) + x + 1;
          s1 += buffer[baseOffset * Math.floor(i / 0xffff + 1) + i];
          s2 += s1;

          if ((n -= 1) != 0) {
            continue;
          }

          s1 %= BASE;
          s2 %= BASE;
          n = NMAX;
        }
      }

      s1 %= BASE;
      s2 %= BASE;
      write4(buffer, this.idat_offs + this.idat_size - 8, (s2 << 16) | s1);

      lookUpCrc32(buffer, this.ihdr_offs, this.ihdr_size);
      lookUpCrc32(buffer, this.plte_offs, this.plte_size);
      lookUpCrc32(buffer, this.trns_offs, this.trns_size);
      lookUpCrc32(buffer, this.idat_offs, this.idat_size);
      lookUpCrc32(buffer, this.iend_offs, this.iend_size);

      return new Uint8Array(this.buffer.buffer);
    }

    /**
     * Create an rgb color from rgba values.
     */
    createRGBColor({ r: red, g: green, b: blue, a }: RGB): number {
      const roundedAlpha = Math.round(a * 255);
      const alpha = roundedAlpha >= 0 ? roundedAlpha : 255;

      const color = ((((((alpha << 8) | red) << 8) | green) << 8) | blue).toString();
      if (this.palette[color] === undefined) {
        if (this.pIndex == this.depth) {
          return 0;
        }

        const ndx = this.plte_offs + 8 + 3 * this.pIndex;

        this.buffer[ndx] = red;
        this.buffer[ndx + 1] = green;
        this.buffer[ndx + 2] = blue;
        this.buffer[this.trns_offs + 8 + this.pIndex] = alpha;

        this.palette[color] = this.pIndex++;
      }

      return this.palette[color];
    }
  }

  // Generate a custom 100x100 PNG image with a white background and red rectangle in the center.
  const png = new PngImage(100, 100, 10, { r: 255, g: 255, b: 255, a: 1 });

  const color = png.createRGBColor({ r: 255, g: 0, b: 0, a: 1 });
  png.drawRect(25, 25, 75, 75, color);

  return { body: png.getBuffer() };
})();
